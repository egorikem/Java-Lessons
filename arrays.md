# Массив

[<img src="http://developer.alexanderklimov.ru/android/java/array.jpg">](http://developer.alexanderklimov.ru/android/java/array.jpg)

(да, тут котики, а пример про цабачек. Потому что я так захотел, ЭЭЭЭ!)


## Что ты есть?

Массив - сухим научным определением – это последовательность упорядоченных элементов одного типа, доступ к каждому элементу в которой осуществляется по его индексу. 

Ничего не понятно, давайте разбираться.

Представим, что у нас есть некоторое количесто собачек, которые все живут в большой длинной будке. Допустим, что в ней 10 цабачьих квартир. У каждой квартиры есть ее номер, и соответсвенно цабака, которая в ней живет.

Можем ли мы узнать, какая цабака живет в квартире номер 4? Можем, просто попорив собаку с номером квартиры 4 рассказать о себе. И так же мы можем в, скажем, квартиру с номером 7 поселить новую цабаку.

Это и есть основная идея массива. Хранить несколько значений **одного типа** (если туда поселить кошечку, то скорее всего цабаки будут недовольны), к которым мы можем иметь доступ на чтение (получение значения) и запись (присвоение значения).

 >Переменная, которая находится в массиве называется "элемент". У элемента массива всего две характеристики: индекс и значение

## Размер массива

Когда мы говорили о будке цабак, мы сказали "некоторое количество". Так вот, при инициализации массива этот размер надо явно указывать. 

На это есть несколько причин, и некоторые смежные с массивом структуры данных умеют автоматически уменьшать/увеличивать размер, на основании количества элементов. Но важно понимать, что:

Если мы обратимся (попытаемся получить значение или присвоить новое) к элементу с **несуществующим индексом**, то у нас будет ошибка: такого элемента просто нету.

Несуществующий индекс это любой индекс меньше `0` (индекс начинается с нуля) и больше `размер_массива -1` (-1 потому что, как мы сказали, индекс начинается с нуля)

## Коварный индекс

Программисты - ленивые и практичные люди. В реальном мире, когда мы говорим: "у меня есть два яблока", и нас попросят их посчитать, мы скажем: яблоко 1, яблоко 2. И как бы логично, что номер первого яблока – 1, второго – 2. 

Но **идекс начинается с нуля**. Это правило, во всех языках программирования. Это просто чуть более эффективно.

Поэтому, если у нас есть массив из 2 яблок, то индекс первого яблока будет 0, второго - 1. Это может сломать мозг, но это просто правило, которое надо знать.

## Синтаксис

Синтаксис достаточно прост. Все, что нам нужно – знать ключевое слово для типа данных (которые мы будет хранить в массиве), рядом с которым мы поставим `[]`– комманда, которая дасть понять, программе, что это массив. И использовать ключевое слово `new` (новый) для инициализации этого массива.

>Важно понимать, что массив - это тоже переменная. Переменная типа "массив целочисленных чисел" или "массив строк"

Пример 1: Объявление массива
```java 
тип_данных[] имя_переменной;
```

>Если мы сразу попытаемся сделать с ним какую-то операцию, мы получим ошибку: так как он не проинициализирован.

Пример 2: Инициализация массива
```java 
имя_переменной = new тип_данных[];
```
 1
Пример 3: Объявление и Инициализация массива
```java 
// В одну строку
тип_данных[] имя_переменной_1 = new тип_данных[]; // Объявление и инициализация
// В две строки
тип_данных[] имя_переменной_2; // Объявление
имя_переменной_2 = new тип_данных[]; // Инициализаци]
```

## Инициализация массива со значенимями

Удобства ради, массив можно инициализировать с неявным указанием размера, а сразу перечислить, какие в нем будут элементы.

Синтаксис прост:

`тип_данных[] = {значние_0, значение_1, ... значение_i};`

Пример 4:
```java
int[] numbers = {1,3,5,10,-19};
```

## Операции над массивом

Итак, мы поняли, что массив – это удобно для хранения однотипных данных. Соответсвенно, ввиду того, что тип у них одинаковый, у нас большое количество вещей, которые можно делать над массивом. Но все они базируются на двух основных принципах:

### Схематическое представление массива

Для упрощения понимания (да и вообще рисовать, когда не понятно – здравая практика), мы будем преставлять массив в ввиде `[элемент_0, элемент_1, ... элемент_i]`.

К примеру, массив со значениями 1,4,5 мы представим как `[1,4,5]`. Тут удобно считать индекс (Какой индекс у элемента со значеним 4? Ответ: 1)

### Чтение значения элемента

>Важно понимать, что после инициализации значения всех эллементов массива – пустые

Синтаксис этой операции прост:

`имя_массива[индекс]`

```java
int[] numbers = {1,3,6};
numbers[0]; // Значение: 1
numbers[1]; // Значение: 3
numbers[2]; // Значение: 6

numbers[3]; // Ошибка! Нету такого индекса

int firstNumber = numbers[1]; // Присвоение значения 1-ого элемента (Число 3) новой переменной firstNumber;
firstNumber; // Значение: 3
```

Пример 5:

### Изменение значения элемента

Синтаксис этой операции тоже прост:

`имя_массива[индекс] = значение;`

Пример 6:
```java
int[] numbers = new int[3]; // Визуализация массива: [0,0,0]
numbers[0] = 100; // Визуализация массива: [100,0,0]
numbets[1] = 120; // Визуализация массива: [100,120,0]
numbets[2] = -3; // Визуализация массива: [100,120,-3]
```

## Практическое применение

Мы узнали, что может читать и записывать заначения элементов массива (по индексу, причем). Как нам это может помочь?

Применений очень много: хранение сообщений в чате, контакты в телефонной книге, заявки на покупку резиновых членов и так далее.

Рассмотрим использование массива вот для какой задачки: 
```
У нас есть котики. 
У любого котика есть такой параметр, как уровень сачастья, и если он больше 10, то котик счастлив. 
Значения уровня счастья наших котиков: 10, 11, 8.  
Мы хотим вевести в консоль информацию о каждом котике: счастлив ли он
```

Прочтив условие, мы понимаем, что у нас есть 3 переменных одинакового типа `int` и нам нужно будет для каждой переменной сделать проверку. Это уже с ходу значит, что нам нужно будет использовать массив и цикл `for`.

Приступим:

Пример 7.1
```java
int requiredHappy = 10; // Require - требовать. "требуемое счастье" – переменная, с которой мы будем сравнивать счастье каждого котика
int[] catsHappy = {10,11,8}; // Создадим массив чисел, которые показывают счастье наших котов
```

Теперь напишем цикл, в котором нам надо сравнить значение счастья каждого кота с треубемым значением:

>Чтобы узнать размер массива, можно использовать синтаксис `имя_массива.length`. Эта операция вернет `int` значение длинны.

Пример 7.2
```java
 int requiredHappy = 10; // Require - требовать. "требуемое счастье" – переменная, с которой мы будем сравнивать счастье каждого котика
 int[] catsHappy = {10,11,8}; // Создадим массив чисел, которые показывают счастье наших котов

 // Пройдемся цилком по всем элементам (зная значение i - индекса этого элемента)
 for(int i=0; i < catsHappy.length; i++) {
    /*
        Больше или равно ли значение элемента массива
        catsHappy с индексом i значению переменной requiredHappy?
     */
    if(catsHappy[i] >= requiredHappy) {
        System.out.println("Котик номер: " + i + " счастлив!");
    }
    else {
        System.out.println("Котик номер: " + i + " пока еще не счастлив :c");
    }
 }
```

Результат:
```
Котик номер: 0 счастлив!
Котик номер: 1 счастлив!
Котик номер: 2 пока еще не счастлив :c
```





